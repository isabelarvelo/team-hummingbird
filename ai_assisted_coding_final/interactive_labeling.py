# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_interactive_labeling.ipynb.

# %% auto 0
__all__ = ['read_csv', 'process_lines', 'label_data', 'create_df_from_list', 'increase_batch_size', 'process_batch',
           'get_user_labels', 'calculate_accuracy']

# %% ../nbs/03_interactive_labeling.ipynb 6
def read_csv(file_path):
    import pandas as pd
    df = pd.read_csv(file_path)
    return df['Text'].tolist()

# %% ../nbs/03_interactive_labeling.ipynb 7
def process_lines(lines, assistant_manager, context=""):
    """
    Process a list of text lines to assign labels based on the content, using an AI assistant manager.

    This function takes multiple text lines, combines them with additional context, and submits them to an AI assistant for processing. Each line is expected to be a separate utterance. 
    The AI assistant analyzes the content and returns labels for each line. The labels are filtered to ensure they belong to a predefined set of valid labels. If an error occurs during processing, a default label is assigned to each line.

    Parameters:
    - lines (list of str): A list of text lines (utterances) to be processed.
    - assistant_manager (AssistantManager): An instance of AssistantManager to handle the communication with the AI assistant.
    - context (str, optional): Additional context to be appended to the text lines before processing. Defaults to an empty string.

    Returns:
    - list of tuples: A list where each tuple contains a line and its corresponding label. For example: [('line1', 'NEU'), ('line2', 'OTR')].

    Raises:
    - Exception: Captures and prints any exception that occurs during the API call to the assistant manager, with a fallback to default labeling.

    Note:
    The function assumes a specific format for the AI assistant's response and predefined valid labels ["NEU", "OTR", "PRS", "REP"]. It defaults to "NEU" for any label not in the valid set or in case of an error.
    """
    data = []
    additional_context = "Return a list of labels for each utterance. Each utterance is separated by \n"
    context += additional_context
    assistant_manager.create_thread(context)

    all_lines = "\n ".join(lines)

    try:
        completed_run = assistant_manager.submit_message(all_lines)
        response_page = assistant_manager.get_response()
        messages = [msg for msg in response_page] 
        assistant_message = messages[-1].content[0].text.value
        labels = assistant_message.replace('\n', ' ').replace(',', ' ').split()

        # Check if labels are one of the specified labels
        valid_labels = ["NEU", "OTR", "PRS", "REP"]
        labels = [label if label in valid_labels else "NEU" for label in labels]

    except Exception as e:
        # Handle any exception that occurred during API call
        print(f"An error occurred: {e}")
        # Default to "NEU" for all lines in case of an error
        labels = ["NEU"] * len(lines)

    # append tuple (line, label) to data using zip
    data = list(zip(lines, labels))

    return(data)

# %% ../nbs/03_interactive_labeling.ipynb 8
def label_data(unlabeled_text):
    """
    Prompts the user to label the given input.

    Args:
    unlabeled_text (str): The text data that needs labeling.

    Returns:
    str: The label provided by the user.
    """
    #print(f"Label the following line: {unlabeled_text}")
    label = input("Enter the correct label: ")
    while label not in ["NEU", "OTR", "PRS", "REP"]:
        print("Invalid label. Please enter a valid label.")
        label = input("Enter the correct label: ")

    return label

# %% ../nbs/03_interactive_labeling.ipynb 9
def create_df_from_list(text_list):
    import pandas as pd 
    return pd.DataFrame(text_list, columns=["Text"])

# %% ../nbs/03_interactive_labeling.ipynb 10
def increase_batch_size(batch_size, accuracy):
    """
    Increase batch size if accuracy is above 90%.
    
    """
    if accuracy <= 0.90:
        batch_size = 5
    elif accuracy > 0.90:
        batch_size = 10
    return batch_size

# %% ../nbs/03_interactive_labeling.ipynb 11
def process_batch(unlabeled_data, start_index, batch_size, batch_sizes):
    """
    Process a batch of data and return the actual batch size which may be less than the batch size if the end of the data is reached.
    """
    end_of_batch = min(start_index + batch_size, len(unlabeled_data))
    actual_batch = unlabeled_data[start_index:end_of_batch]
    actual_batch_size = len(actual_batch)
    batch_sizes.append(actual_batch_size)  # Actual number of items in the batch
    return actual_batch, actual_batch_size


# %% ../nbs/03_interactive_labeling.ipynb 12
def get_user_labels(batch, assistant_manager, context):
    """ 
    Get user labels for a batch of data.
    """
    import time 
    predictions = process_lines(batch, assistant_manager, context)
    labeled_data = []
    correct_responses = 0

    for text, prediction in predictions:
        print(f"Predicted for '{text}': {prediction}")
        time.sleep(1)
        user_decision = input(f"Do you agree with this label? (Y/N): ")

        correct_label = label_data(text) if user_decision.lower() != 'y' else prediction
        correct_responses += correct_label == prediction
        context += f"\nuser: '{text}'\nassistant: '{correct_label}'"
        labeled_data.append((text, correct_label))

    return labeled_data, correct_responses



# %% ../nbs/03_interactive_labeling.ipynb 13
def calculate_accuracy(correct_responses, batch_size):
    """
    Calculate accuracy for a batch of data.
    """
    return correct_responses / batch_size if batch_size > 0 else 0
